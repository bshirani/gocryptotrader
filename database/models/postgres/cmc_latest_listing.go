// Code generated by SQLBoiler 4.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package postgres

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// CMCLatestListing is an object representing the database table.
type CMCLatestListing struct {
	ID                     int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	LastUpdated            time.Time   `boil:"last_updated" json:"last_updated" toml:"last_updated" yaml:"last_updated"`
	MarketCap              float64     `boil:"market_cap" json:"market_cap" toml:"market_cap" yaml:"market_cap"`
	MarketCapDominance     float64     `boil:"market_cap_dominance" json:"market_cap_dominance" toml:"market_cap_dominance" yaml:"market_cap_dominance"`
	PercentChange1H        float64     `boil:"percent_change_1h" json:"percent_change_1h" toml:"percent_change_1h" yaml:"percent_change_1h"`
	PercentChange24H       float64     `boil:"percent_change_24h" json:"percent_change_24h" toml:"percent_change_24h" yaml:"percent_change_24h"`
	PercentChange7D        float64     `boil:"percent_change_7d" json:"percent_change_7d" toml:"percent_change_7d" yaml:"percent_change_7d"`
	PercentChange30D       float64     `boil:"percent_change_30d" json:"percent_change_30d" toml:"percent_change_30d" yaml:"percent_change_30d"`
	PercentChange60D       float64     `boil:"percent_change_60d" json:"percent_change_60d" toml:"percent_change_60d" yaml:"percent_change_60d"`
	PercentChange90D       float64     `boil:"percent_change_90d" json:"percent_change_90d" toml:"percent_change_90d" yaml:"percent_change_90d"`
	PercentChangeVolume24H float64     `boil:"percent_change_volume_24h" json:"percent_change_volume_24h" toml:"percent_change_volume_24h" yaml:"percent_change_volume_24h"`
	PercentChangeVolume30D float64     `boil:"percent_change_volume_30d" json:"percent_change_volume_30d" toml:"percent_change_volume_30d" yaml:"percent_change_volume_30d"`
	PercentChangeVolume7D  float64     `boil:"percent_change_volume_7d" json:"percent_change_volume_7d" toml:"percent_change_volume_7d" yaml:"percent_change_volume_7d"`
	Price                  float64     `boil:"price" json:"price" toml:"price" yaml:"price"`
	TotalMarketCap         float64     `boil:"total_market_cap" json:"total_market_cap" toml:"total_market_cap" yaml:"total_market_cap"`
	Volume24H              float64     `boil:"volume_24h" json:"volume_24h" toml:"volume_24h" yaml:"volume_24h"`
	Volume24HReported      float64     `boil:"volume_24h_reported" json:"volume_24h_reported" toml:"volume_24h_reported" yaml:"volume_24h_reported"`
	Volume30D              float64     `boil:"volume_30d" json:"volume_30d" toml:"volume_30d" yaml:"volume_30d"`
	Volume30DReported      float64     `boil:"volume_30d_reported" json:"volume_30d_reported" toml:"volume_30d_reported" yaml:"volume_30d_reported"`
	Volume7D               float64     `boil:"volume_7d" json:"volume_7d" toml:"volume_7d" yaml:"volume_7d"`
	Volume7DReported       float64     `boil:"volume_7d_reported" json:"volume_7d_reported" toml:"volume_7d_reported" yaml:"volume_7d_reported"`
	CirculatingSupply      float64     `boil:"circulating_supply" json:"circulating_supply" toml:"circulating_supply" yaml:"circulating_supply"`
	CMCRank                int         `boil:"cmc_rank" json:"cmc_rank" toml:"cmc_rank" yaml:"cmc_rank"`
	DateAdded              time.Time   `boil:"date_added" json:"date_added" toml:"date_added" yaml:"date_added"`
	FullyDilutedMarketCap  float64     `boil:"fully_diluted_market_cap" json:"fully_diluted_market_cap" toml:"fully_diluted_market_cap" yaml:"fully_diluted_market_cap"`
	MarketCapByTotalSupply float64     `boil:"market_cap_by_total_supply" json:"market_cap_by_total_supply" toml:"market_cap_by_total_supply" yaml:"market_cap_by_total_supply"`
	MaxSupply              float64     `boil:"max_supply" json:"max_supply" toml:"max_supply" yaml:"max_supply"`
	Name                   string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	NumMarketPairs         int         `boil:"num_market_pairs" json:"num_market_pairs" toml:"num_market_pairs" yaml:"num_market_pairs"`
	Slug                   string      `boil:"slug" json:"slug" toml:"slug" yaml:"slug"`
	Symbol                 string      `boil:"symbol" json:"symbol" toml:"symbol" yaml:"symbol"`
	Tags                   null.String `boil:"tags" json:"tags,omitempty" toml:"tags" yaml:"tags,omitempty"`
	TotalSupply            float64     `boil:"total_supply" json:"total_supply" toml:"total_supply" yaml:"total_supply"`
	VolumeChange24H        float64     `boil:"volume_change_24h" json:"volume_change_24h" toml:"volume_change_24h" yaml:"volume_change_24h"`
	CreatedAt              time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt              time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *cmcLatestListingR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L cmcLatestListingL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CMCLatestListingColumns = struct {
	ID                     string
	LastUpdated            string
	MarketCap              string
	MarketCapDominance     string
	PercentChange1H        string
	PercentChange24H       string
	PercentChange7D        string
	PercentChange30D       string
	PercentChange60D       string
	PercentChange90D       string
	PercentChangeVolume24H string
	PercentChangeVolume30D string
	PercentChangeVolume7D  string
	Price                  string
	TotalMarketCap         string
	Volume24H              string
	Volume24HReported      string
	Volume30D              string
	Volume30DReported      string
	Volume7D               string
	Volume7DReported       string
	CirculatingSupply      string
	CMCRank                string
	DateAdded              string
	FullyDilutedMarketCap  string
	MarketCapByTotalSupply string
	MaxSupply              string
	Name                   string
	NumMarketPairs         string
	Slug                   string
	Symbol                 string
	Tags                   string
	TotalSupply            string
	VolumeChange24H        string
	CreatedAt              string
	UpdatedAt              string
}{
	ID:                     "id",
	LastUpdated:            "last_updated",
	MarketCap:              "market_cap",
	MarketCapDominance:     "market_cap_dominance",
	PercentChange1H:        "percent_change_1h",
	PercentChange24H:       "percent_change_24h",
	PercentChange7D:        "percent_change_7d",
	PercentChange30D:       "percent_change_30d",
	PercentChange60D:       "percent_change_60d",
	PercentChange90D:       "percent_change_90d",
	PercentChangeVolume24H: "percent_change_volume_24h",
	PercentChangeVolume30D: "percent_change_volume_30d",
	PercentChangeVolume7D:  "percent_change_volume_7d",
	Price:                  "price",
	TotalMarketCap:         "total_market_cap",
	Volume24H:              "volume_24h",
	Volume24HReported:      "volume_24h_reported",
	Volume30D:              "volume_30d",
	Volume30DReported:      "volume_30d_reported",
	Volume7D:               "volume_7d",
	Volume7DReported:       "volume_7d_reported",
	CirculatingSupply:      "circulating_supply",
	CMCRank:                "cmc_rank",
	DateAdded:              "date_added",
	FullyDilutedMarketCap:  "fully_diluted_market_cap",
	MarketCapByTotalSupply: "market_cap_by_total_supply",
	MaxSupply:              "max_supply",
	Name:                   "name",
	NumMarketPairs:         "num_market_pairs",
	Slug:                   "slug",
	Symbol:                 "symbol",
	Tags:                   "tags",
	TotalSupply:            "total_supply",
	VolumeChange24H:        "volume_change_24h",
	CreatedAt:              "created_at",
	UpdatedAt:              "updated_at",
}

var CMCLatestListingTableColumns = struct {
	ID                     string
	LastUpdated            string
	MarketCap              string
	MarketCapDominance     string
	PercentChange1H        string
	PercentChange24H       string
	PercentChange7D        string
	PercentChange30D       string
	PercentChange60D       string
	PercentChange90D       string
	PercentChangeVolume24H string
	PercentChangeVolume30D string
	PercentChangeVolume7D  string
	Price                  string
	TotalMarketCap         string
	Volume24H              string
	Volume24HReported      string
	Volume30D              string
	Volume30DReported      string
	Volume7D               string
	Volume7DReported       string
	CirculatingSupply      string
	CMCRank                string
	DateAdded              string
	FullyDilutedMarketCap  string
	MarketCapByTotalSupply string
	MaxSupply              string
	Name                   string
	NumMarketPairs         string
	Slug                   string
	Symbol                 string
	Tags                   string
	TotalSupply            string
	VolumeChange24H        string
	CreatedAt              string
	UpdatedAt              string
}{
	ID:                     "cmc_latest_listing.id",
	LastUpdated:            "cmc_latest_listing.last_updated",
	MarketCap:              "cmc_latest_listing.market_cap",
	MarketCapDominance:     "cmc_latest_listing.market_cap_dominance",
	PercentChange1H:        "cmc_latest_listing.percent_change_1h",
	PercentChange24H:       "cmc_latest_listing.percent_change_24h",
	PercentChange7D:        "cmc_latest_listing.percent_change_7d",
	PercentChange30D:       "cmc_latest_listing.percent_change_30d",
	PercentChange60D:       "cmc_latest_listing.percent_change_60d",
	PercentChange90D:       "cmc_latest_listing.percent_change_90d",
	PercentChangeVolume24H: "cmc_latest_listing.percent_change_volume_24h",
	PercentChangeVolume30D: "cmc_latest_listing.percent_change_volume_30d",
	PercentChangeVolume7D:  "cmc_latest_listing.percent_change_volume_7d",
	Price:                  "cmc_latest_listing.price",
	TotalMarketCap:         "cmc_latest_listing.total_market_cap",
	Volume24H:              "cmc_latest_listing.volume_24h",
	Volume24HReported:      "cmc_latest_listing.volume_24h_reported",
	Volume30D:              "cmc_latest_listing.volume_30d",
	Volume30DReported:      "cmc_latest_listing.volume_30d_reported",
	Volume7D:               "cmc_latest_listing.volume_7d",
	Volume7DReported:       "cmc_latest_listing.volume_7d_reported",
	CirculatingSupply:      "cmc_latest_listing.circulating_supply",
	CMCRank:                "cmc_latest_listing.cmc_rank",
	DateAdded:              "cmc_latest_listing.date_added",
	FullyDilutedMarketCap:  "cmc_latest_listing.fully_diluted_market_cap",
	MarketCapByTotalSupply: "cmc_latest_listing.market_cap_by_total_supply",
	MaxSupply:              "cmc_latest_listing.max_supply",
	Name:                   "cmc_latest_listing.name",
	NumMarketPairs:         "cmc_latest_listing.num_market_pairs",
	Slug:                   "cmc_latest_listing.slug",
	Symbol:                 "cmc_latest_listing.symbol",
	Tags:                   "cmc_latest_listing.tags",
	TotalSupply:            "cmc_latest_listing.total_supply",
	VolumeChange24H:        "cmc_latest_listing.volume_change_24h",
	CreatedAt:              "cmc_latest_listing.created_at",
	UpdatedAt:              "cmc_latest_listing.updated_at",
}

// Generated where

var CMCLatestListingWhere = struct {
	ID                     whereHelperint
	LastUpdated            whereHelpertime_Time
	MarketCap              whereHelperfloat64
	MarketCapDominance     whereHelperfloat64
	PercentChange1H        whereHelperfloat64
	PercentChange24H       whereHelperfloat64
	PercentChange7D        whereHelperfloat64
	PercentChange30D       whereHelperfloat64
	PercentChange60D       whereHelperfloat64
	PercentChange90D       whereHelperfloat64
	PercentChangeVolume24H whereHelperfloat64
	PercentChangeVolume30D whereHelperfloat64
	PercentChangeVolume7D  whereHelperfloat64
	Price                  whereHelperfloat64
	TotalMarketCap         whereHelperfloat64
	Volume24H              whereHelperfloat64
	Volume24HReported      whereHelperfloat64
	Volume30D              whereHelperfloat64
	Volume30DReported      whereHelperfloat64
	Volume7D               whereHelperfloat64
	Volume7DReported       whereHelperfloat64
	CirculatingSupply      whereHelperfloat64
	CMCRank                whereHelperint
	DateAdded              whereHelpertime_Time
	FullyDilutedMarketCap  whereHelperfloat64
	MarketCapByTotalSupply whereHelperfloat64
	MaxSupply              whereHelperfloat64
	Name                   whereHelperstring
	NumMarketPairs         whereHelperint
	Slug                   whereHelperstring
	Symbol                 whereHelperstring
	Tags                   whereHelpernull_String
	TotalSupply            whereHelperfloat64
	VolumeChange24H        whereHelperfloat64
	CreatedAt              whereHelpertime_Time
	UpdatedAt              whereHelpertime_Time
}{
	ID:                     whereHelperint{field: "\"cmc_latest_listing\".\"id\""},
	LastUpdated:            whereHelpertime_Time{field: "\"cmc_latest_listing\".\"last_updated\""},
	MarketCap:              whereHelperfloat64{field: "\"cmc_latest_listing\".\"market_cap\""},
	MarketCapDominance:     whereHelperfloat64{field: "\"cmc_latest_listing\".\"market_cap_dominance\""},
	PercentChange1H:        whereHelperfloat64{field: "\"cmc_latest_listing\".\"percent_change_1h\""},
	PercentChange24H:       whereHelperfloat64{field: "\"cmc_latest_listing\".\"percent_change_24h\""},
	PercentChange7D:        whereHelperfloat64{field: "\"cmc_latest_listing\".\"percent_change_7d\""},
	PercentChange30D:       whereHelperfloat64{field: "\"cmc_latest_listing\".\"percent_change_30d\""},
	PercentChange60D:       whereHelperfloat64{field: "\"cmc_latest_listing\".\"percent_change_60d\""},
	PercentChange90D:       whereHelperfloat64{field: "\"cmc_latest_listing\".\"percent_change_90d\""},
	PercentChangeVolume24H: whereHelperfloat64{field: "\"cmc_latest_listing\".\"percent_change_volume_24h\""},
	PercentChangeVolume30D: whereHelperfloat64{field: "\"cmc_latest_listing\".\"percent_change_volume_30d\""},
	PercentChangeVolume7D:  whereHelperfloat64{field: "\"cmc_latest_listing\".\"percent_change_volume_7d\""},
	Price:                  whereHelperfloat64{field: "\"cmc_latest_listing\".\"price\""},
	TotalMarketCap:         whereHelperfloat64{field: "\"cmc_latest_listing\".\"total_market_cap\""},
	Volume24H:              whereHelperfloat64{field: "\"cmc_latest_listing\".\"volume_24h\""},
	Volume24HReported:      whereHelperfloat64{field: "\"cmc_latest_listing\".\"volume_24h_reported\""},
	Volume30D:              whereHelperfloat64{field: "\"cmc_latest_listing\".\"volume_30d\""},
	Volume30DReported:      whereHelperfloat64{field: "\"cmc_latest_listing\".\"volume_30d_reported\""},
	Volume7D:               whereHelperfloat64{field: "\"cmc_latest_listing\".\"volume_7d\""},
	Volume7DReported:       whereHelperfloat64{field: "\"cmc_latest_listing\".\"volume_7d_reported\""},
	CirculatingSupply:      whereHelperfloat64{field: "\"cmc_latest_listing\".\"circulating_supply\""},
	CMCRank:                whereHelperint{field: "\"cmc_latest_listing\".\"cmc_rank\""},
	DateAdded:              whereHelpertime_Time{field: "\"cmc_latest_listing\".\"date_added\""},
	FullyDilutedMarketCap:  whereHelperfloat64{field: "\"cmc_latest_listing\".\"fully_diluted_market_cap\""},
	MarketCapByTotalSupply: whereHelperfloat64{field: "\"cmc_latest_listing\".\"market_cap_by_total_supply\""},
	MaxSupply:              whereHelperfloat64{field: "\"cmc_latest_listing\".\"max_supply\""},
	Name:                   whereHelperstring{field: "\"cmc_latest_listing\".\"name\""},
	NumMarketPairs:         whereHelperint{field: "\"cmc_latest_listing\".\"num_market_pairs\""},
	Slug:                   whereHelperstring{field: "\"cmc_latest_listing\".\"slug\""},
	Symbol:                 whereHelperstring{field: "\"cmc_latest_listing\".\"symbol\""},
	Tags:                   whereHelpernull_String{field: "\"cmc_latest_listing\".\"tags\""},
	TotalSupply:            whereHelperfloat64{field: "\"cmc_latest_listing\".\"total_supply\""},
	VolumeChange24H:        whereHelperfloat64{field: "\"cmc_latest_listing\".\"volume_change_24h\""},
	CreatedAt:              whereHelpertime_Time{field: "\"cmc_latest_listing\".\"created_at\""},
	UpdatedAt:              whereHelpertime_Time{field: "\"cmc_latest_listing\".\"updated_at\""},
}

// CMCLatestListingRels is where relationship names are stored.
var CMCLatestListingRels = struct {
}{}

// cmcLatestListingR is where relationships are stored.
type cmcLatestListingR struct {
}

// NewStruct creates a new relationship struct
func (*cmcLatestListingR) NewStruct() *cmcLatestListingR {
	return &cmcLatestListingR{}
}

// cmcLatestListingL is where Load methods for each relationship are stored.
type cmcLatestListingL struct{}

var (
	cmcLatestListingAllColumns            = []string{"id", "last_updated", "market_cap", "market_cap_dominance", "percent_change_1h", "percent_change_24h", "percent_change_7d", "percent_change_30d", "percent_change_60d", "percent_change_90d", "percent_change_volume_24h", "percent_change_volume_30d", "percent_change_volume_7d", "price", "total_market_cap", "volume_24h", "volume_24h_reported", "volume_30d", "volume_30d_reported", "volume_7d", "volume_7d_reported", "circulating_supply", "cmc_rank", "date_added", "fully_diluted_market_cap", "market_cap_by_total_supply", "max_supply", "name", "num_market_pairs", "slug", "symbol", "tags", "total_supply", "volume_change_24h", "created_at", "updated_at"}
	cmcLatestListingColumnsWithoutDefault = []string{"last_updated", "market_cap", "market_cap_dominance", "percent_change_1h", "percent_change_24h", "percent_change_7d", "percent_change_30d", "percent_change_60d", "percent_change_90d", "percent_change_volume_24h", "percent_change_volume_30d", "percent_change_volume_7d", "price", "total_market_cap", "volume_24h", "volume_24h_reported", "volume_30d", "volume_30d_reported", "volume_7d", "volume_7d_reported", "circulating_supply", "cmc_rank", "date_added", "fully_diluted_market_cap", "market_cap_by_total_supply", "max_supply", "name", "num_market_pairs", "slug", "symbol", "tags", "total_supply", "volume_change_24h"}
	cmcLatestListingColumnsWithDefault    = []string{"id", "created_at", "updated_at"}
	cmcLatestListingPrimaryKeyColumns     = []string{"id"}
)

type (
	// CMCLatestListingSlice is an alias for a slice of pointers to CMCLatestListing.
	// This should almost always be used instead of []CMCLatestListing.
	CMCLatestListingSlice []*CMCLatestListing
	// CMCLatestListingHook is the signature for custom CMCLatestListing hook methods
	CMCLatestListingHook func(context.Context, boil.ContextExecutor, *CMCLatestListing) error

	cmcLatestListingQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	cmcLatestListingType                 = reflect.TypeOf(&CMCLatestListing{})
	cmcLatestListingMapping              = queries.MakeStructMapping(cmcLatestListingType)
	cmcLatestListingPrimaryKeyMapping, _ = queries.BindMapping(cmcLatestListingType, cmcLatestListingMapping, cmcLatestListingPrimaryKeyColumns)
	cmcLatestListingInsertCacheMut       sync.RWMutex
	cmcLatestListingInsertCache          = make(map[string]insertCache)
	cmcLatestListingUpdateCacheMut       sync.RWMutex
	cmcLatestListingUpdateCache          = make(map[string]updateCache)
	cmcLatestListingUpsertCacheMut       sync.RWMutex
	cmcLatestListingUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var cmcLatestListingBeforeInsertHooks []CMCLatestListingHook
var cmcLatestListingBeforeUpdateHooks []CMCLatestListingHook
var cmcLatestListingBeforeDeleteHooks []CMCLatestListingHook
var cmcLatestListingBeforeUpsertHooks []CMCLatestListingHook

var cmcLatestListingAfterInsertHooks []CMCLatestListingHook
var cmcLatestListingAfterSelectHooks []CMCLatestListingHook
var cmcLatestListingAfterUpdateHooks []CMCLatestListingHook
var cmcLatestListingAfterDeleteHooks []CMCLatestListingHook
var cmcLatestListingAfterUpsertHooks []CMCLatestListingHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CMCLatestListing) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmcLatestListingBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CMCLatestListing) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmcLatestListingBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CMCLatestListing) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmcLatestListingBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CMCLatestListing) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmcLatestListingBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CMCLatestListing) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmcLatestListingAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CMCLatestListing) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmcLatestListingAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CMCLatestListing) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmcLatestListingAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CMCLatestListing) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmcLatestListingAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CMCLatestListing) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmcLatestListingAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCMCLatestListingHook registers your hook function for all future operations.
func AddCMCLatestListingHook(hookPoint boil.HookPoint, cmcLatestListingHook CMCLatestListingHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		cmcLatestListingBeforeInsertHooks = append(cmcLatestListingBeforeInsertHooks, cmcLatestListingHook)
	case boil.BeforeUpdateHook:
		cmcLatestListingBeforeUpdateHooks = append(cmcLatestListingBeforeUpdateHooks, cmcLatestListingHook)
	case boil.BeforeDeleteHook:
		cmcLatestListingBeforeDeleteHooks = append(cmcLatestListingBeforeDeleteHooks, cmcLatestListingHook)
	case boil.BeforeUpsertHook:
		cmcLatestListingBeforeUpsertHooks = append(cmcLatestListingBeforeUpsertHooks, cmcLatestListingHook)
	case boil.AfterInsertHook:
		cmcLatestListingAfterInsertHooks = append(cmcLatestListingAfterInsertHooks, cmcLatestListingHook)
	case boil.AfterSelectHook:
		cmcLatestListingAfterSelectHooks = append(cmcLatestListingAfterSelectHooks, cmcLatestListingHook)
	case boil.AfterUpdateHook:
		cmcLatestListingAfterUpdateHooks = append(cmcLatestListingAfterUpdateHooks, cmcLatestListingHook)
	case boil.AfterDeleteHook:
		cmcLatestListingAfterDeleteHooks = append(cmcLatestListingAfterDeleteHooks, cmcLatestListingHook)
	case boil.AfterUpsertHook:
		cmcLatestListingAfterUpsertHooks = append(cmcLatestListingAfterUpsertHooks, cmcLatestListingHook)
	}
}

// One returns a single cmcLatestListing record from the query.
func (q cmcLatestListingQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CMCLatestListing, error) {
	o := &CMCLatestListing{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "postgres: failed to execute a one query for cmc_latest_listing")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CMCLatestListing records from the query.
func (q cmcLatestListingQuery) All(ctx context.Context, exec boil.ContextExecutor) (CMCLatestListingSlice, error) {
	var o []*CMCLatestListing

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "postgres: failed to assign all query results to CMCLatestListing slice")
	}

	if len(cmcLatestListingAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CMCLatestListing records in the query.
func (q cmcLatestListingQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "postgres: failed to count cmc_latest_listing rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q cmcLatestListingQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "postgres: failed to check if cmc_latest_listing exists")
	}

	return count > 0, nil
}

// CMCLatestListings retrieves all the records using an executor.
func CMCLatestListings(mods ...qm.QueryMod) cmcLatestListingQuery {
	mods = append(mods, qm.From("\"cmc_latest_listing\""))
	return cmcLatestListingQuery{NewQuery(mods...)}
}

// FindCMCLatestListing retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCMCLatestListing(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*CMCLatestListing, error) {
	cmcLatestListingObj := &CMCLatestListing{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"cmc_latest_listing\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, cmcLatestListingObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "postgres: unable to select from cmc_latest_listing")
	}

	if err = cmcLatestListingObj.doAfterSelectHooks(ctx, exec); err != nil {
		return cmcLatestListingObj, err
	}

	return cmcLatestListingObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CMCLatestListing) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("postgres: no cmc_latest_listing provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmcLatestListingColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	cmcLatestListingInsertCacheMut.RLock()
	cache, cached := cmcLatestListingInsertCache[key]
	cmcLatestListingInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			cmcLatestListingAllColumns,
			cmcLatestListingColumnsWithDefault,
			cmcLatestListingColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(cmcLatestListingType, cmcLatestListingMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(cmcLatestListingType, cmcLatestListingMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"cmc_latest_listing\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"cmc_latest_listing\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "postgres: unable to insert into cmc_latest_listing")
	}

	if !cached {
		cmcLatestListingInsertCacheMut.Lock()
		cmcLatestListingInsertCache[key] = cache
		cmcLatestListingInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the CMCLatestListing.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CMCLatestListing) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	cmcLatestListingUpdateCacheMut.RLock()
	cache, cached := cmcLatestListingUpdateCache[key]
	cmcLatestListingUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			cmcLatestListingAllColumns,
			cmcLatestListingPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("postgres: unable to update cmc_latest_listing, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"cmc_latest_listing\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, cmcLatestListingPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(cmcLatestListingType, cmcLatestListingMapping, append(wl, cmcLatestListingPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "postgres: unable to update cmc_latest_listing row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "postgres: failed to get rows affected by update for cmc_latest_listing")
	}

	if !cached {
		cmcLatestListingUpdateCacheMut.Lock()
		cmcLatestListingUpdateCache[key] = cache
		cmcLatestListingUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q cmcLatestListingQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "postgres: unable to update all for cmc_latest_listing")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "postgres: unable to retrieve rows affected for cmc_latest_listing")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CMCLatestListingSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("postgres: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmcLatestListingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"cmc_latest_listing\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, cmcLatestListingPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "postgres: unable to update all in cmcLatestListing slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "postgres: unable to retrieve rows affected all in update all cmcLatestListing")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CMCLatestListing) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("postgres: no cmc_latest_listing provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmcLatestListingColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	cmcLatestListingUpsertCacheMut.RLock()
	cache, cached := cmcLatestListingUpsertCache[key]
	cmcLatestListingUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			cmcLatestListingAllColumns,
			cmcLatestListingColumnsWithDefault,
			cmcLatestListingColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			cmcLatestListingAllColumns,
			cmcLatestListingPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("postgres: unable to upsert cmc_latest_listing, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(cmcLatestListingPrimaryKeyColumns))
			copy(conflict, cmcLatestListingPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"cmc_latest_listing\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(cmcLatestListingType, cmcLatestListingMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(cmcLatestListingType, cmcLatestListingMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "postgres: unable to upsert cmc_latest_listing")
	}

	if !cached {
		cmcLatestListingUpsertCacheMut.Lock()
		cmcLatestListingUpsertCache[key] = cache
		cmcLatestListingUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single CMCLatestListing record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CMCLatestListing) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("postgres: no CMCLatestListing provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cmcLatestListingPrimaryKeyMapping)
	sql := "DELETE FROM \"cmc_latest_listing\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "postgres: unable to delete from cmc_latest_listing")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "postgres: failed to get rows affected by delete for cmc_latest_listing")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q cmcLatestListingQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("postgres: no cmcLatestListingQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "postgres: unable to delete all from cmc_latest_listing")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "postgres: failed to get rows affected by deleteall for cmc_latest_listing")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CMCLatestListingSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(cmcLatestListingBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmcLatestListingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"cmc_latest_listing\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cmcLatestListingPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "postgres: unable to delete all from cmcLatestListing slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "postgres: failed to get rows affected by deleteall for cmc_latest_listing")
	}

	if len(cmcLatestListingAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CMCLatestListing) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCMCLatestListing(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CMCLatestListingSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CMCLatestListingSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmcLatestListingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"cmc_latest_listing\".* FROM \"cmc_latest_listing\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cmcLatestListingPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "postgres: unable to reload all in CMCLatestListingSlice")
	}

	*o = slice

	return nil
}

// CMCLatestListingExists checks if the CMCLatestListing row exists.
func CMCLatestListingExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"cmc_latest_listing\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "postgres: unable to check if cmc_latest_listing exists")
	}

	return exists, nil
}
