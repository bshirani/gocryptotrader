strategies can trade long and short at the same time
the portfolio determines the final trade size and makes sure it is in compliance



backtester:

- portfolio is created in backtest.NewFromConfig()
- call portfolio.Setup()
- load the strategy class by name
- processSignalEvent receives event from strategy and calls portfolio.OnSignal

what is IPairReserver

when dry run is disabled

when the portfolio starts, it loads the trades from the trades table
it keeps a map of strategies to their trades
it updates trades in the trades table every 30 seconds

backtester has exchange and portfolio

backtester handle event ->
    signal ->  portfolio.OnSignal
    order ->  exchange.ExecuteOrder, submits fake order
    fill -> portfolio.OnFill


exchange.ExecuteOrder is where the trade should be saved to the database
exchange is a fake broker

for live trading our positions are updated from the real broker


backtester has an event queue which is continuously pulls from and processes
it can process one of three event types, signal order fill

we need the backtester to keep track of the trades that it's in
if it gives a signal to trade, it should record that trade in the database and in memory for future reference

the best place to keep track of this kind of information is in the portfolio

when we create a new order, we should keep track of that order until it's been processed

strategy can have an empty order

strategy needs to keep track of its order
strategy needs to keep track of its position/trade

the order manager (writes the order to the database) and executes the order
receive a fill event
(update the order in the database)

portfolio has many orders, positions, and strategies
can retrieve orders and positions per strategy, or per currency
when an order is created, we also create a position with the appropriate state
as we receive updates on the order, we update the position
when the order is filled, we track the position updates
we must exit the position
strategies


strategy callbacks
on_start
on_order
on_trade/on_position
on_stop


the portfolio has a DataManager
BarManager

BarDataSeriesManager
minute
daily

backtest:
    load bars from database
live:
    catchup
    save the live bars in the database


print trades to csv
print factors to csv
run live with weights
run portfolio backtest
same as running multiple strategies
do you want to analyze the results independently?
can export both
trades manager exports factors, portfolio_trades, trades_by_model


i need stop losses
in real trading we will separate orders for entry and for the stop loss trigger, which is a market order
for fake trading, we will want to operate in the same manner. create the same orders.

what does the order manager do exactly? how does it operate? we will need to understand this

how does the portfolio get notified of order manager events?
we can pass a callback function, but that's a little messy is there a better way?






portfolio creates an order.Submit
it stores it to the database
it emits an order.CreateEvent
trade manager processes order - Create
    trade manager calls exchange.ExecuteOrder with details of that order.Event
    ExecuteOrder returns an OrderSubmitResponse
    trade manager emits a submit.Event (order can be placed or not)
trade manager processes order - Submit
    Submit processing calls the portfoliolo OnSubmit


the portfolio can call the excecution handler to transmit the order
how does the portfolio get notified of executions?

lets try it with channels
we want to create a channel on the portfolio that we pass to the order manager



the fake order manager always get a submission response

ExcutionHandler.Submit() *order.SubitResponse


portfolio.OnSignal creates an order event
order event is processed by trade manager
trade manager receive on submit callback


the order manager has its own store
we could either recreate the data or just reference the existing store for order information

we have live trading
we have backtesting
we have factor engine
we have multiple symbols
we have multiple strategies
we have the same code for live and backtest

we have a database
we have live trades and orders
we have strategies able to decide by time, profit, factors


a websocket routine manager is running as its own subsystem
WRM started
creates a shutdown channel
creates a websocket routine
for each exchange, run concurrently:
- obtain websocket connection
- connect to websocket connection
log error if there is one
create a websocket data receiver in a go routine
flush the channels of the websocket // why?
the websocket data receiver runs a for/select loop listening for shutdown or a websocket routine
when it receives a routine, it calls the websocket data handler
it logs an error if there is one
websocket data handler can handle different types of messages

data wise, we can receive:
ticker.Price
stream.KlineData

deploy strategies
deploy portfolio
real trading
analyze strategies
improve results
deploy portfolio

sync the orders with the broker
use a real order manager


when a strategy creates an order signal
and the portfolio accepts it
the portfolio stores the order in the database status NEW
when the portfolio receives the fill event
- it stores the order as CLOSED
- it creates a TRADE status ACTIVE

more strategies
backtesting individual strategies
caching factors
longer-term strategies, backtested, in a loop

keep track of the strategies in the database
keep track of the pairs being traded in the database

retrieve the active currencies and strategies from the database instead of the configuration

load the strategies from the database instead of configuration


backtest a strategy and get the performance numbers for it
analyze a trades.csv and generate a simple report for it
basic weight determination for a set of strategies from a csv



portfolio backtest
deciding which strategies to deploy on a daily basis
dynamically enabling/disabling pairs/strategies


when in backtest mode:
- on every data point, we need to update the order manager
- this is to check for stop loss or take profits that have been activated
- thus we can notify the portfolio to record the trade as closed

when we add an order to the store

when we create a submit order, we also create orders that represent the stop loss and take profit

if I receive an exit order, I should cancel the stop loss order
that's the responsibility of the trademanager

- cancel the stop loss order when we exit in trade_manager.execute_order
- callback from om to tm when stop loss is hit

- when the stop loss is hit, the trade manager needs to cancel the stop loss order


X backtesting
X strategy statistics
X portfolio statistics
X get all the backtests in a single CSV
X or get the backtests in separate CSVs
X combine them together into a portfolio analysis
X output the results json and prod configuration json


X now analyze the trades. Set a weight of 1 to winning strategies, and 0 to losers.
X Write the non-zero weighted strategies to prod config



analyze the performance of the strategies
- % winners
- expectancy
- average win/loss
- percentage of months profitable

- one month long backtest on all strategies

- make position sizing respect account balance and risk threshold


- position sizing
- maximum drawdown
- weeks profitable %


factors:
X - whats the range of the past 10/20/30/50/100 bars
X - whats the market trendiness over the past 10/20/30/50/100 bars
X calculate the slope of the best fit line


portfolio backtest
machine learning each strategy

how would a portfolio backtest work with static weights?
how often would you update the weights?

why not start with a single profitable strategy first?
how would you build a single profitable strategy, and THEN apply it to other markets?
what's wrong with this approach?

remember, everything can be tested and will be tested.

how do I classify the market conditions?

I can use a neural network

what's another way?
I can measure the conditions of profitability
though how do I use those measures?
wouldn't it resemble something like a NN model?
nn seems fun/easy but im not sure if it's useful

let's get a basic NN running

a single profitable trading strategy

open range breakout
volatility breakout
trend day
reversal breakout
support/resistence breakout

when do these models make money?

make a strategy for each of these on several different time frames/intervals
use the same strategy across several intervals.

e.g. get the straegies working on both 1 minute interval, 3 minute, 5 minute, 15 minute, 1 hour

create a portfolio backtest and get the results

get a neural network running for each strategy
train and test

see if we can get a performance improvement

run prediction
run analysis
observe difference, see if there's improvement
keep trying until you see an improvement
classify the conditions under which the strategy is performing under

long term trendiness
we need more features
how do we get more features
I need information about the days
how do I want to handle strategies with multiple time intervals?

each strategy can request any number of time intervals

just make it work for one to start

create real predictions
give false input to prove it works

- what's the distribution of the data

/automl?num_strategies=n&

use cases:
- run automl on 5-20 strategies, analyze the results of those specific trading models
- run train + predict on all strategies (1000+) and analyze the results of each of those specific models

offline mode:
>> model experiment num-strategies=5
>> model train strategies=all
>> model eval strategies=all

live mode:
>> model run

provides http API to enable strategies to get real-time inference

I should definitely use python for this because most data science tools are coded in python.
Then interface between the go app and python using REST or files on the same drive

I definitely should use python for the data science stuff

I need to have a way to evaluate the results back in go to tell me the improvement.

or I just keep it all in python for this part


the key is to develop an API that will abstract the machine learning techniques used
one that will not have to change, while being able to modify completely how the machine learning operates

from the perspective of the application we only have few actions that need to be taken

backtest:
1. run experiments and train models. get the results for the models and display them. run a search of all machine learning algorithms, find the best one, then show the result
2. train + predict chosen model on all strategies, show results

live:
1. run live models for real-time inference


there are different AutoML tools. we can use all of them. we don't have to choose one.
first build the API to make sure taht you can run experiements and evaluate results
codify all your desired fitness functions and scoring methods (sortino ratio, for example)

cleanup your input data

ensure works in real time

live operation API
backtest operation API

create the backtest operation API
create the live operation API

python experiment.py
- returns the best model code
- returns the results of the best model applied on the input data

automl libraries:
- pycaret
- tpot
- autokeras
- autovi_ml
- autogluon
- mljar-supervised
- automl-gs

serving libraries live mode:
- bentoml

feature engineering:
- tsfresh
- fb prophet

goal today:
- experiment generates a model gleamed from several strategies, produces best model
- model is train/eval on each strategy
- measure the current performance metric


# apply the prediction and return an actual sortino ratio for the strategy


run backtest

goal: build a model
offline/backtest python - backtest models, apply prediction, get results

what is the performance improvement?
what is the sortino ratio of the strategy without a model?
what is the sortino ratio of the strategy with the model with all application methods


Add features, rerun backtest
repeat the process until a successful trading strategy is found
then deploy the model far and wide

live mode is easy to understand and apply

focus now on:


modeling variables:
- strategies: i.e. entries/exits
- features
- fitness functions
- feature selection methods
- kinds of models
- application methods

observe:
- performance results of individual strategies

add targets definition
add features
improve entries/exits
run backtest
run experiment, view results
repeat until profitable

add daily data to factors
we need to handle minutes and days

do we want to handle different time series besides minutes?
say 5 minutes, 15 minutes? 1 hour?
yes yes yes

so how will we add daily data?

will each strategy have a daily data stream?
will each strategy have multiple data streams?
will we add the daily data to the event itself?
all the data ultimately will end up in the factor calculations as the strategies are stateless,
so focus there

how do I add daily data

without having to scan an entire day.
I could scan an entire day, that's fine.
or just start at midnight

so the strategies will need one day of warmup
they will require all daily data to have been downloaded already
they will be loaded....
