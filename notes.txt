strategies can trade long and short at the same time
the portfolio determines the final trade size and makes sure it is in compliance



backtester:

- portfolio is created in backtest.NewFromConfig()
- call portfolio.Setup()
- load the strategy class by name
- processSignalEvent receives event from strategy and calls portfolio.OnSignal

what is IPairReserver

when dry run is disabled

when the portfolio starts, it loads the trades from the trades table
it keeps a map of strategies to their trades
it updates trades in the trades table every 30 seconds

backtester has exchange and portfolio

backtester handle event ->
    signal ->  portfolio.OnSignal
    order ->  exchange.ExecuteOrder, submits fake order
    fill -> portfolio.OnFill


exchange.ExecuteOrder is where the trade should be saved to the database
exchange is a fake broker

for live trading our positions are updated from the real broker


backtester has an event queue which is continuously pulls from and processes
it can process one of three event types, signal order fill

we need the backtester to keep track of the trades that it's in
if it gives a signal to trade, it should record that trade in the database and in memory for future reference

the best place to keep track of this kind of information is in the portfolio

when we create a new order, we should keep track of that order until it's been processed

strategy can have an empty order

strategy needs to keep track of its order
strategy needs to keep track of its position/trade

the order manager (writes the order to the database) and executes the order
receive a fill event
(update the order in the database)

portfolio has many orders, positions, and strategies
can retrieve orders and positions per strategy, or per currency
when an order is created, we also create a position with the appropriate state
as we receive updates on the order, we update the position
when the order is filled, we track the position updates
we must exit the position
strategies


strategy callbacks
on_start
on_order
on_trade/on_position
on_stop


the portfolio has a DataManager
BarManager

BarDataSeriesManager
minute
daily

backtest:
    load bars from database
live:
    catchup
    save the live bars in the database


print trades to csv
print factors to csv
run live with weights
run portfolio backtest
same as running multiple strategies
do you want to analyze the results independently?
can export both
trades manager exports factors, portfolio_trades, trades_by_model


i need stop losses
in real trading we will separate orders for entry and for the stop loss trigger, which is a market order
for fake trading, we will want to operate in the same manner. create the same orders.

what does the order manager do exactly? how does it operate? we will need to understand this

how does the portfolio get notified of order manager events?
we can pass a callback function, but that's a little messy is there a better way?






portfolio creates an order.Submit
it stores it to the database
it emits an order.CreateEvent
trade manager processes order - Create
    trade manager calls exchange.ExecuteOrder with details of that order.Event
    ExecuteOrder returns an OrderSubmitResponse
    trade manager emits a submit.Event (order can be placed or not)
trade manager processes order - Submit
    Submit processing calls the portfoliolo OnSubmit


the portfolio can call the excecution handler to transmit the order
how does the portfolio get notified of executions?

lets try it with channels
we want to create a channel on the portfolio that we pass to the order manager



the fake order manager always get a submission response

ExcutionHandler.Submit() *order.SubitResponse


portfolio.OnSignal creates an order event
order event is processed by trade manager
trade manager receive on submit callback


the order manager has its own store
we could either recreate the data or just reference the existing store for order information

we have live trading
we have backtesting
we have factor engine
we have multiple symbols
we have multiple strategies
we have the same code for live and backtest

we have a database
we have live trades and orders
we have strategies able to decide by time, profit, factors


a websocket routine manager is running as its own subsystem
WRM started
creates a shutdown channel
creates a websocket routine
for each exchange, run concurrently:
- obtain websocket connection
- connect to websocket connection
log error if there is one
create a websocket data receiver in a go routine
flush the channels of the websocket // why?
the websocket data receiver runs a for/select loop listening for shutdown or a websocket routine
when it receives a routine, it calls the websocket data handler
it logs an error if there is one
websocket data handler can handle different types of messages

data wise, we can receive:
ticker.Price
stream.KlineData

deploy strategies
deploy portfolio
real trading
analyze strategies
improve results
deploy portfolio

sync the orders with the broker
use a real order manager


when a strategy creates an order signal
and the portfolio accepts it
the portfolio stores the order in the database status NEW
when the portfolio receives the fill event
- it stores the order as CLOSED
- it creates a TRADE status ACTIVE

more strategies
backtesting individual strategies
caching factors
longer-term strategies, backtested, in a loop

keep track of the strategies in the database
keep track of the pairs being traded in the database

retrieve the active currencies and strategies from the database instead of the configuration

load the strategies from the database instead of configuration


backtest a strategy and get the performance numbers for it
analyze a trades.csv and generate a simple report for it
basic weight determination for a set of strategies from a csv



portfolio backtest
deciding which strategies to deploy on a daily basis
dynamically enabling/disabling pairs/strategies


when in backtest mode:
- on every data point, we need to update the order manager
- this is to check for stop loss or take profits that have been activated
- thus we can notify the portfolio to record the trade as closed

when we add an order to the store

when we create a submit order, we also create orders that represent the stop loss and take profit

if I receive an exit order, I should cancel the stop loss order
that's the responsibility of the trademanager

- cancel the stop loss order when we exit in trade_manager.execute_order
- callback from om to tm when stop loss is hit

- when the stop loss is hit, the trade manager needs to cancel the stop loss order


X backtesting
X strategy statistics
X portfolio statistics
X get all the backtests in a single CSV
X or get the backtests in separate CSVs
X combine them together into a portfolio analysis
X output the results json and prod configuration json


X now analyze the trades. Set a weight of 1 to winning strategies, and 0 to losers.
X Write the non-zero weighted strategies to prod config



analyze the performance of the strategies
- % winners
- expectancy
- average win/loss
- percentage of months profitable

- one month long backtest on all strategies

- make position sizing respect account balance and risk threshold


- position sizing
- maximum drawdown
- weeks profitable %


factors:
X - whats the range of the past 10/20/30/50/100 bars
X - whats the market trendiness over the past 10/20/30/50/100 bars
X calculate the slope of the best fit line


portfolio backtest
machine learning each strategy

how would a portfolio backtest work with static weights?
how often would you update the weights?

why not start with a single profitable strategy first?
how would you build a single profitable strategy, and THEN apply it to other markets?
what's wrong with this approach?

remember, everything can be tested and will be tested.

how do I classify the market conditions?

I can use a neural network

what's another way?
I can measure the conditions of profitability
though how do I use those measures?
wouldn't it resemble something like a NN model?
nn seems fun/easy but im not sure if it's useful

let's get a basic NN running

a single profitable trading strategy

open range breakout
volatility breakout
trend day
reversal breakout
support/resistence breakout

when do these models make money?

make a strategy for each of these on several different time frames/intervals
use the same strategy across several intervals.

e.g. get the straegies working on both 1 minute interval, 3 minute, 5 minute, 15 minute, 1 hour

create a portfolio backtest and get the results

get a neural network running for each strategy
train and test

see if we can get a performance improvement

run prediction
run analysis
observe difference, see if there's improvement
keep trying until you see an improvement
classify the conditions under which the strategy is performing under

long term trendiness
we need more features
how do we get more features
I need information about the days
how do I want to handle strategies with multiple time intervals?

each strategy can request any number of time intervals

just make it work for one to start

create real predictions
give false input to prove it works

- what's the distribution of the data

/automl?num_strategies=n&

use cases:
- run automl on 5-20 strategies, analyze the results of those specific trading models
- run train + predict on all strategies (1000+) and analyze the results of each of those specific models

offline mode:
>> model experiment num-strategies=5
>> model train strategies=all
>> model eval strategies=all

live mode:
>> model run

provides http API to enable strategies to get real-time inference

I should definitely use python for this because most data science tools are coded in python.
Then interface between the go app and python using REST or files on the same drive

I definitely should use python for the data science stuff

I need to have a way to evaluate the results back in go to tell me the improvement.

or I just keep it all in python for this part


the key is to develop an API that will abstract the machine learning techniques used
one that will not have to change, while being able to modify completely how the machine learning operates

from the perspective of the application we only have few actions that need to be taken

backtest:
1. run experiments and train models. get the results for the models and display them. run a search of all machine learning algorithms, find the best one, then show the result
2. train + predict chosen model on all strategies, show results

live:
1. run live models for real-time inference


there are different AutoML tools. we can use all of them. we don't have to choose one.
first build the API to make sure taht you can run experiements and evaluate results
codify all your desired fitness functions and scoring methods (sortino ratio, for example)

cleanup your input data

ensure works in real time

live operation API
backtest operation API

create the backtest operation API
create the live operation API

python experiment.py
- returns the best model code
- returns the results of the best model applied on the input data

automl libraries:
- pycaret
- tpot
- autokeras
- autovi_ml
- autogluon
- mljar-supervised
- automl-gs

serving libraries live mode:
- bentoml

feature engineering:
- tsfresh
- fb prophet

goal today:
- experiment generates a model gleamed from several strategies, produces best model
- model is train/eval on each strategy
- measure the current performance metric


# apply the prediction and return an actual sortino ratio for the strategy


run backtest

goal: build a model
offline/backtest python - backtest models, apply prediction, get results

what is the performance improvement?
what is the sortino ratio of the strategy without a model?
what is the sortino ratio of the strategy with the model with all application methods


Add features, rerun backtest
repeat the process until a successful trading strategy is found
then deploy the model far and wide

live mode is easy to understand and apply

focus now on:


modeling variables:
- strategies: i.e. entries/exits
- features
- fitness functions
- feature selection methods
- kinds of models
- application methods

observe:
- performance results of individual strategies

add targets definition
add features
improve entries/exits
run backtest
run experiment, view results
repeat until profitable

add daily data to factors
we need to handle minutes and days

do we want to handle different time series besides minutes?
say 5 minutes, 15 minutes? 1 hour?
yes yes yes

so how will we add daily data?

will each strategy have a daily data stream?
will each strategy have multiple data streams?
will we add the daily data to the event itself?
all the data ultimately will end up in the factor calculations as the strategies are stateless,
so focus there

how do I add daily data

without having to scan an entire day.
I could scan an entire day, that's fine.
or just start at midnight

so the strategies will need one day of warmup
they will require all daily data to have been downloaded already
they will be loaded...

=======================
modeling

the current problem is that when a signal is made, we need to keep track of that trade
otherwise the strategy will create a signal, do a request to the model, and decide whether to trade or now.

currently, if the strategy has no trades, it is eligble to make a new trade
based on the current training data,
we would need to make a fake trade if a real one is not made
this means the system needs to handle fake/simulated and real trades at the same time

this is only to keep track that the strategy has created a new trade

another way to do this would be to keep track of all strategy signals treat it as a type of order or a separate entity altogether.

the easiest way to do this

treat an enter signal from a strategy as an order of sorts

periodic retraining
OR
online machine learning

is this an optimization?
yes

can we do without it?
as long as we can periodically retrain and run the backtest, online machine learning is not necessary
we would want to have ways of measuring concept drift

- concept drift
- non-stationary distrubutions
- imbalanced data

get a production system running

do we have any considerations
no considerations
full speed

do I need to be able to make a fake trade and a live trade at the same time?
do I need to be able to always make a fake trade?

what would it take to do that?
would I have to store it the same as a live trade

is this necessary?

what else could I do?
what's the purpose of this?
the purpose is that the predictions match the backtest
the purpose is that the real-time predictions match the backtest
in a backtest, we get the trades from the strategies and then apply the signals after

no this has nothing to do with backtesting.

we want to be able to take a negative prediction for a straegy's trade, but to still simulate the trade

another alternative would be to prevent the trading of a strategy for some period of time after it has made a prediction
another alternative would be to not prevent the strategy at all from generating a signal for each  minute, and ensuring that the backtests also match the functionality of the system in this manner


i generate an entry signal
a negative decision is returned from the model
what prevents the next minute from generating another signal?
or should htis be prevented at all?
I think it makes sense to prevent it, but it seems like a lot of work to implement this feature that may not be necesarry. If I do not make this change that means that I'd have to modify the way the backtesting works also

the goal is to prevent trading for a strategy until the next valid signal is made

one way this could be accomplished is in the form of an order
a record that the strategy has given a signal
a timeframe that the signal is valid for

a signal could be something like an order

when a strategy creates an entry signal, it saves it as an order type signal
the signal then needs a prediction, which it will request from the ML model
The strategy is only allowed one signal per period of time that is specified as a strategy parameter

So a strategy could be set to only trade once per day in this way



do I need to make a fake trade?

you might as well simulate the trades
what's the best way to do this?

you want a fake trade to be made?
why are we doing this?
CAPTURE THE FUCKING OPPORTUNITIES

in and backtest mode
we will create a fake trade to let the strategy know that it's made it's decision

what's another way to do this?
Set a timeout on the entry signals that can be made for a period of time

this would imply that multiple trades can be made be a strategy at once which is not desirable at this time

so the

do I make a fake trade?
do I keep track of entry signals?

if i keep track of entry signals, and do not make the trades
i need to know when that entry signal is valid for, so I can reset it to allow the strategy to trade again

this might be a good chance to implement the X time period to allow trades
the only problem with this is that currently some trades might go past this time window, which I want to allow

but in backtesting, this would allow the strategy to execute a new trade while it's still in one

a fake trade seems to give me what I want

how would a fake trade work?

always use the fake order manager
always use it to make a fake trade

how do I reconcile fake and real trades?

if the real trade stops out, I need to close both the fake and real trade


if i make a real trade, do I need a fake trade?
do I distinguish all orders and trades as fake or real?


there are two options:

- pretend like the trade was made in the system, though it wasn't, in order to allow the strategy to think it's trading, and to only trade once per period maximum.

OR

i need to evalulate which one is better for the top level goal of the system

the top level goal
is it desirable to have the strategy create a fake trade
or to keep track of an entry signal?

we need context

iwe need to keep track of a strategy and keep it in line with backtest
though this manner affects backtesting also

we would have to change the results we look at
and scope things by whether it's real or simulated

this would have to apply to orders and trades

currently the system does fake orders
but it does real orders in production mode
now we want to change it to always either do a fake or real trade
the real order manager will always run with the fake order manager

there is no fake order manager. there's only a single order manager.

if I use entry signals
keep track of them
set a timeout
this will overlap with the results of the system
the results will change accordingly

if a trade is made, it won't trade again
if a trade is not made because of a negative prediction,
the entry signal is still created and can prevent the creation of new trades for a period of time
I think this is much simpler than fake trades, which makes the whole system confusing

the entry signal can solve the problem with less confusion and complexity
but what are the implications?
it's much simpler

what are the negative implications?
I can't think of any
why would I rather have fake trades?
I wouldnt if I could just use entry signals
needs to work same in BT as real life
the system doesn't tell the difference between those two things


the livesignal is created via portfolio.OnSignal

PORTFOLIO BACKTEST
NEVER STOPS WORKING

PB ERR DAY

the goal of today is to have a portfolio backtest

that's the only goal

I want to do a portfolio backtest

this involves retraining the model
I have to run the model
generate teh trades
then train the machine learning for each model
then continue the backtest

the alternative is to do online-learning

i either can run the retraining periodically during the operation of the system

or I can setup an online machine learning system

I think I should skip online-learning right now

it seems more difficult to do right
I don't know if I have the necessary models in order to do this

let's try it and see how it does first

that could save a lot of work


I start the system and it begins training
I start the backtest and it starts training
periodically it will retrain the models via a worker pool

try this with one strategy first

let's generate some trades, then every X days it will retrain using the data within some range
this will require passing all the inputs at once via api to python for training

the trade manager will facilitate this

why would I have an active stop loss when I don't have an active trade?

I should never be in this situation

when a trade is exited, we close out signals to allow the strategy to trade again

ensure you only save the last valid signal per strategy

>> train a model after n trades

>> year long backtest with all models

>> get all predicted trades
>> get all trades with portfolio weights
>> get all model trades for 1 year
>> get all model trades for all data


full system test from beginning to end

the system is running from zero
the calculations are gathered
the trades are made without concern to prediction
once there are enough trades, a training is commenced on that strategy's model
this process is done periodically to keep the model updated
PERIODIC RETRAINING


in live trading
there is no retraining
Instead, a cronjob will run that will train models that should be trained and have a window of time available
should this not be possible with a future strategy then a concurrent retraining process will be implemented


I'm going to have a separate system to manage the machine learning backtesting
and to analyze the results
this system will also be responsible for analyzing teh results of the portfolio optimization

it will be an experimentation framework


soletsgo

prediction
go
I need separated trade files
then I update the trade files
go


>> retrain every 30 traes
either get it working with bityard
or kucoin

bityard at least works now

kucoin

do a backtest with gate.io
use gate.io via mexican identity

live does not work right now
it is trying to reach history that it does not have
it does a warmup, then it requests a out of bounds range

should I skip it, or should I ensure that the history is not zeroed out after warmup?

what is the data being requested, and what is the context

it is requesting the base statistics for a given bar to calculate the features
it is using a data handler
in this case, after live starts running the data handler has no history,
should it be skipped, or shouldf the data handler have the history of the warmup?

it is trying to get the data for a specific n range
it should return a null ncalculation, why doesn't it?
should it return a null calculation?
it already has the data but it cannot access it in this context since we are using a different data handler
is this important? is this necessary?

how do I deploy a single model?

you can turn on the existing program to run a single model
there are some limitations
but it's possible now
what else do you want?

I don't know how to successfully accomplish projects
especially long-term projects
long-lasting projects

i realize that simplicity is key
but that's not all

I don't think I respect production enough, and that my production is small

my production is not well-defined
what defines what runs in production?
how do I qualify a winning strategy?
one that makes money you MONKEY

get a portfolio of models out for bitcoin and ethereum TODAY MONKEY

ok so we have the live models running, now what?
now make sure it doesn't go down again, then refine it

how do you define the next tasks?
how do you decide what to spend time on?
how do you know if what you have is good enough?
how do you make changes to a live running system without messing up what's already running?

how do you decide which strategies to trade and how much of each?

first get a live running system going

get a portfolio backtest running of the strategies you have running
provide updated results for each version of the deployed strategy
each deployed version of the model will have a portoflio backtest result into each build
that way we can track what the prediction is vs the actual results over time

speed

how much ram is required you think?
to run 50 strategies?


run the system with a single strategy
don't let it stop running
the next step will be making it profitable
for now just get the system running

what's the next step?
to get the system running
gate.io

one trade per day
daily timeframe

next we will add multiple strategies and weights

it looks like we don't have contracts available for gate.io, only spot
FUCK

So at this point, we could probably use kucoin and it would be the same

# 2022-01-22

Here's the plan:

- we need to create backtests
- what is the end goal?

- which currencies am I going to trade?
- how am I going to make money from this?

I need uncorrelated strategies
I need to test as many strategies as possible
What's the goal?
First get a backtest of all your strategies

What am I going to do with all the results of the backtests?
How am I going to aggregate all of them into a report?

Currently each backtesting run outputs all of its trades into a csv file




