strategies can trade long and short at the same time
the portfolio determines the final trade size and makes sure it is in compliance



backtester:

- portfolio is created in backtest.NewFromConfig()
- call portfolio.Setup()
- load the strategy class by name
- processSignalEvent receives event from strategy and calls portfolio.OnSignal

what is IPairReserver

when dry run is disabled

when the portfolio starts, it loads the trades from the trades table
it keeps a map of strategies to their trades
it updates trades in the trades table every 30 seconds

backtester has exchange and portfolio

backtester handle event ->
    signal ->  portfolio.OnSignal
    order ->  exchange.ExecuteOrder, submits fake order
    fill -> portfolio.OnFill


exchange.ExecuteOrder is where the trade should be saved to the database
exchange is a fake broker

for live trading our positions are updated from the real broker


backtester has an event queue which is continuously pulls from and processes
it can process one of three event types, signal order fill

we need the backtester to keep track of the trades that it's in
if it gives a signal to trade, it should record that trade in the database and in memory for future reference

the best place to keep track of this kind of information is in the portfolio

when we create a new order, we should keep track of that order until it's been processed

strategy can have an empty order

strategy needs to keep track of its order
strategy needs to keep track of its position/trade

the order manager (writes the order to the database) and executes the order
receive a fill event
(update the order in the database)

portfolio has many orders, positions, and strategies
can retrieve orders and positions per strategy, or per currency
when an order is created, we also create a position with the appropriate state
as we receive updates on the order, we update the position
when the order is filled, we track the position updates
we must exit the position
strategies


strategy callbacks
on_start
on_order
on_trade/on_position
on_stop


the portfolio has a DataManager
BarManager

BarDataSeriesManager
minute
daily

backtest:
    load bars from database
live:
    catchup
    save the live bars in the database


print trades to csv
print factors to csv
run live with weights
run portfolio backtest
same as running multiple strategies
do you want to analyze the results independently?
can export both
trades manager exports factors, portfolio_trades, trades_by_model


i need stop losses
in real trading we will separate orders for entry and for the stop loss trigger, which is a market order
for fake trading, we will want to operate in the same manner. create the same orders.

what does the order manager do exactly? how does it operate? we will need to understand this

how does the portfolio get notified of order manager events?
we can pass a callback function, but that's a little messy is there a better way?






portfolio creates an order.Submit
it stores it to the database
it emits an order.CreateEvent
trade manager processes order - Create
    trade manager calls exchange.ExecuteOrder with details of that order.Event
    ExecuteOrder returns an OrderSubmitResponse
    trade manager emits a submit.Event (order can be placed or not)
trade manager processes order - Submit
    Submit processing calls the portfoliolo OnSubmit


the portfolio can call the excecution handler to transmit the order
how does the portfolio get notified of executions?

lets try it with channels
we want to create a channel on the portfolio that we pass to the order manager



the fake order manager always get a submission response

ExcutionHandler.Submit() *order.SubitResponse


portfolio.OnSignal creates an order event
order event is processed by trade manager
trade manager receive on submit callback


the order manager has its own store
we could either recreate the data or just reference the existing store for order information

we have live trading
we have backtesting
we have factor engine
we have multiple symbols
we have multiple strategies
we have the same code for live and backtest

we have a database
we have live trades and orders
we have strategies able to decide by time, profit, factors


a websocket routine manager is running as its own subsystem
WRM started
creates a shutdown channel
creates a websocket routine
for each exchange, run concurrently:
- obtain websocket connection
- connect to websocket connection
log error if there is one
create a websocket data receiver in a go routine
flush the channels of the websocket // why?
the websocket data receiver runs a for/select loop listening for shutdown or a websocket routine
when it receives a routine, it calls the websocket data handler
it logs an error if there is one
websocket data handler can handle different types of messages

data wise, we can receive:
ticker.Price
stream.KlineData

deploy strategies
deploy portfolio
real trading
analyze strategies
improve results
deploy portfolio

sync the orders with the broker
use a real order manager


when a strategy creates an order signal
and the portfolio accepts it
the portfolio stores the order in the database status NEW
when the portfolio receives the fill event
- it stores the order as CLOSED
- it creates a TRADE status ACTIVE

more strategies
backtesting individual strategies
caching factors
longer-term strategies, backtested, in a loop

keep track of the strategies in the database
keep track of the pairs being traded in the database

retrieve the active currencies and strategies from the database instead of the configuration

load the strategies from the database instead of configuration


backtest a strategy and get the performance numbers for it
analyze a trades.csv and generate a simple report for it
basic weight determination for a set of strategies from a csv



portfolio backtest
deciding which strategies to deploy on a daily basis
dynamically enabling/disabling pairs/strategies


when in backtest mode:
- on every data point, we need to update the order manager
- this is to check for stop loss or take profits that have been activated
- thus we can notify the portfolio to record the trade as closed

when we add an order to the store

when we create a submit order, we also create orders that represent the stop loss and take profit

if I receive an exit order, I should cancel the stop loss order
that's the responsibility of the trademanager

- cancel the stop loss order when we exit in trade_manager.execute_order
- callback from om to tm when stop loss is hit

- when the stop loss is hit, the trade manager needs to cancel the stop loss order


X backtesting
X strategy statistics
X portfolio statistics
X get all the backtests in a single CSV
X or get the backtests in separate CSVs
X combine them together into a portfolio analysis
X output the results json and prod configuration json


now analyze the trades. Set a weight of 1 to winning strategies, and 0 to losers.
Write the non-zero weighted strategies to prod config
